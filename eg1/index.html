<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Maze Game with Radar Effect</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #000;
    }
    canvas {
      border: 2px solid #0f0;
    }
  </style>
</head>
<body>
  <script>
    let maze;
    let player;
    let cellSize = 40;
    let cols, rows;
    let radarAngle = 0;
    let radarRange = 100;
    
    function setup() {
      createCanvas(600, 600);
      cols = floor(width / cellSize);
      rows = floor(height / cellSize);
      maze = generateMaze(cols, rows);
      player = { x: 1, y: 1 }; // Start position
    }
    
    function draw() {
      background(0);
      drawMaze();
      drawRadar();
      drawPlayer();
      radarAngle += 0.05; // Rotate radar
    }
    
    function generateMaze(cols, rows) {
      let grid = [];
      // Initialize grid
      for (let y = 0; y < rows; y++) {
        grid[y] = [];
        for (let x = 0; x < cols; x++) {
          grid[y][x] = { walls: [true, true, true, true], visited: false }; // Top, Right, Bottom, Left
        }
      }
      // Recursive backtracking
      function carve(x, y) {
        grid[y][x].visited = true;
        let directions = shuffle([[0, -1], [1, 0], [0, 1], [-1, 0]]); // Up, Right, Down, Left
        for (let [dx, dy] of directions) {
          let nx = x + dx;
          let ny = y + dy;
          if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !grid[ny][nx].visited) {
            if (dx === 1) { // Right
              grid[y][x].walls[1] = false;
              grid[ny][nx].walls[3] = false;
            } else if (dx === -1) { // Left
              grid[y][x].walls[3] = false;
              grid[ny][nx].walls[1] = false;
            } else if (dy === 1) { // Down
              grid[y][x].walls[2] = false;
              grid[ny][nx].walls[0] = false;
            } else if (dy === -1) { // Up
              grid[y][x].walls[0] = false;
              grid[ny][nx].walls[2] = false;
            }
            carve(nx, ny);
          }
        }
      }
      carve(0, 0);
      // Set end point
      grid[rows - 2][cols - 2].walls = [false, false, false, false]; // Open end
      return grid;
    }
    
    function drawMaze() {
      stroke(0, 255, 0);
      strokeWeight(2);
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          let cellX = x * cellSize;
          let cellY = y * cellSize;
          // Only draw walls within radar range
          let d = dist(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2, cellX + cellSize / 2, cellY + cellSize / 2);
          if (d > radarRange) continue;
          if (maze[y][x].walls[0]) line(cellX, cellY, cellX + cellSize, cellY); // Top
          if (maze[y][x].walls[1]) line(cellX + cellSize, cellY, cellX + cellSize, cellY + cellSize); // Right
          if (maze[y][x].walls[2]) line(cellX, cellY + cellSize, cellX + cellSize, cellY + cellSize); // Bottom
          if (maze[y][x].walls[3]) line(cellX, cellY, cellX, cellY + cellSize); // Left
        }
      }
      // Draw end point
      fill(255, 0, 0);
      noStroke();
      rect((cols - 2) * cellSize + 10, (rows - 2) * cellSize + 10, cellSize - 20, cellSize - 20);
    }
    
    function drawRadar() {
      push();
      translate(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2);
      rotate(radarAngle);
      fill(0, 255, 0, 50);
      noStroke();
      arc(0, 0, radarRange * 2, radarRange * 2, 0, PI / 4);
      pop();
    }
    
    function drawPlayer() {
      fill(0, 255, 0);
      noStroke();
      ellipse(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2, cellSize / 2);
    }
    
    function keyPressed() {
      let newX = player.x;
      let newY = player.y;
      if (keyCode === UP_ARROW && !maze[player.y][player.x].walls[0]) newY--;
      if (keyCode === RIGHT_ARROW && !maze[player.y][player.x].walls[1]) newX++;
      if (keyCode === DOWN_ARROW && !maze[player.y][player.x].walls[2]) newY++;
      if (keyCode === LEFT_ARROW && !maze[player.y][player.x].walls[3]) newX--;
      if (newX >= 0 && newX < cols && newY >= 0 && newY < rows) {
        player.x = newX;
        player.y = newY;
      }
      // Check if player reached the end
      if (player.x === cols - 2 && player.y === rows - 2) {
        alert("Congratulations! You reached the end!");
        player.x = 1;
        player.y = 1;
        maze = generateMaze(cols, rows);
      }
    }
  </script>
</body>
</html>