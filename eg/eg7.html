<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>RPG v0.0.8 - First Person with Fixed Rotation Animations</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #000;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      width: 100vw;
      height: calc(100vh - 80px);
      max-width: 800px;
      max-height: 800px;
    }
    #controls {
      position: fixed;
      bottom: 10px;
      display: grid;
      grid-template-areas: 
        ". up ."
        "left . right";
      gap: 15px;
      width: 90%;
      max-width: 300px;
      justify-items: center;
      align-items: center;
      z-index: 10;
    }
    .control-btn {
      width: 60px;
      height: 60px;
      background: #0f0;
      border: 2px solid #0f0;
      border-radius: 8px;
      color: #000;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
      cursor: pointer;
    }
    #up { grid-area: up; }
    #left { grid-area: left; }
    #right { grid-area: right; }
    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #fff;
      font-size: 16px;
      font-family: Arial, sans-serif;
      z-index: 10;
    }
    @media (max-width: 400px) {
      .control-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }
      #controls {
        gap: 10px;
        bottom: 5px;
      }
      canvas {
        height: calc(100vh - 60px);
      }
    }
    @media (min-width: 601px) {
      .control-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
    }
  </style>
</head>
<body>
  <div id="hud">Score: 0  HP: 100</div>
  <div id="controls">
    <div class="control-btn" id="up">¡ü</div>
    <div class="control-btn" id="left">¡û</div>
    <div class="control-btn" id="right">¡ú</div>
  </div>
  <script>
    let scene, camera, renderer, playerMesh, radarLight;
    let maze, regions, player, cols, rows, cellSize;
    let radarAngle = 0;
    let radarRange = 3;
    let animationState = { isAnimating: false, type: null, startTime: 0, duration: 300 }; // Animation control in ms

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(90, window.innerWidth / (window.innerHeight - 80), 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      let size = Math.min(window.innerWidth, window.innerHeight - 80, 800);
      renderer.setSize(size, size);
      document.body.appendChild(renderer.domElement);

      cellSize = 1;
      cols = 12;
      rows = 12;
      maze = generateMaze(cols, rows);
      regions = generateRegions();
      player = { x: 1, y: 1, score: 0, hp: 100, direction: 0 }; // 0: North, 1: East, 2: South, 3: West

      createMazeGeometry();
      createPlayer();

      const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
      scene.add(ambientLight);
      radarLight = new THREE.SpotLight(0x00ff00, 0.5, radarRange * cellSize * 2, Math.PI / 4);
      scene.add(radarLight);

      updateCamera();

      document.getElementById('up').addEventListener('touchstart', (e) => { e.preventDefault(); movePlayer(38); });
      document.getElementById('left').addEventListener('touchstart', (e) => { e.preventDefault(); rotatePlayer('left'); });
      document.getElementById('right').addEventListener('touchstart', (e) => { e.preventDefault(); rotatePlayer('right'); });
      document.addEventListener('keydown', (e) => {
        if (e.keyCode === 38) movePlayer(38);
        if (e.keyCode === 37) rotatePlayer('left');
        if (e.keyCode === 39) rotatePlayer('right');
      });
      window.addEventListener('resize', onWindowResize);

      animate();
    }

    function generateMaze(cols, rows) {
      let grid = [];
      for (let y = 0; y < rows; y++) {
        grid[y] = [];
        for (let x = 0; x < cols; x++) {
          grid[y][x] = { walls: [true, true, true, true], visited: false };
        }
      }
      function carve(x, y) {
        grid[y][x].visited = true;
        let directions = shuffle([[0, -1], [1, 0], [0, 1], [-1, 0]]);
        for (let [dx, dy] of directions) {
          let nx = x + dx;
          let ny = y + dy;
          if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !grid[ny][nx].visited) {
            if (dx === 1) {
              grid[y][x].walls[1] = false;
              grid[ny][nx].walls[3] = false;
            } else if (dx === -1) {
              grid[y][x].walls[3] = false;
              grid[ny][nx].walls[1] = false;
            } else if (dy === 1) {
              grid[y][x].walls[2] = false;
              grid[ny][nx].walls[0] = false;
            } else if (dy === -1) {
              grid[y][x].walls[0] = false;
              grid[ny][nx].walls[2] = false;
            }
            carve(nx, ny);
          }
        }
      }
      carve(0, 0);
      grid[rows - 2][cols - 2].walls = [false, false, false, false];
      return grid;
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function generateRegions() {
      let regions = [];
      const types = [
        { type: 'Normal', wallColor: 0x00ff00, floorColor: 0x003300 },
        { type: 'Danger', wallColor: 0xff0000, floorColor: 0x330000 },
        { type: 'Treasure', wallColor: 0xffff00, floorColor: 0x333300 },
        { type: 'Safe', wallColor: 0x0000ff, floorColor: 0x000033 }
      ];
      for (let y = 0; y < rows; y++) {
        regions[y] = [];
        for (let x = 0; x < cols; x++) {
          regions[y][x] = types[Math.floor(Math.random() * 4)];
        }
      }
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (x < cols - 3) {
            while (
              regions[y][x].type === regions[y][x + 1].type &&
              regions[y][x].type === regions[y][x + 2].type &&
              regions[y][x].type === regions[y][x + 3].type
            ) {
              regions[y][x + 3] = types.filter(t => t.type !== regions[y][x].type)[Math.floor(Math.random() * 3)];
            }
          }
          if (y < rows - 3) {
            while (
              regions[y][x].type === regions[y + 1][x].type &&
              regions[y][x].type === regions[y + 2][x].type &&
              regions[y][x].type === regions[y + 3][x].type
            ) {
              regions[y + 3][x] = types.filter(t => t.type !== regions[y][x].type)[Math.floor(Math.random() * 3)];
            }
          }
        }
      }
      regions[1][1] = types[0];
      regions[rows - 2][cols - 2] = types[3];
      return regions;
    }

    function createMazeGeometry() {
      const wallHeight = 1;
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          let floorGeo = new THREE.PlaneGeometry(cellSize, cellSize);
          let floorMat = new THREE.MeshLambertMaterial({ color: regions[y][x].floorColor });
          let floor = new THREE.Mesh(floorGeo, floorMat);
          floor.rotation.x = -Math.PI / 2;
          floor.position.set(x * cellSize, 0, y * cellSize);
          scene.add(floor);

          let wallGeo = new THREE.BoxGeometry(cellSize, wallHeight, 0.1);
          let wallMat = new THREE.MeshLambertMaterial({ color: regions[y][x].wallColor });
          if (maze[y][x].walls[0]) {
            let wall = new THREE.Mesh(wallGeo, wallMat);
            wall.position.set(x * cellSize, wallHeight / 2, y * cellSize - cellSize / 2);
            scene.add(wall);
          }
          if (maze[y][x].walls[1]) {
            let wall = new THREE.Mesh(wallGeo, wallMat);
            wall.rotation.y = Math.PI / 2;
            wall.position.set(x * cellSize + cellSize / 2, wallHeight / 2, y * cellSize);
            scene.add(wall);
          }
          if (maze[y][x].walls[2]) {
            let wall = new THREE.Mesh(wallGeo, wallMat);
            wall.position.set(x * cellSize, wallHeight / 2, y * cellSize + cellSize / 2);
            scene.add(wall);
          }
          if (maze[y][x].walls[3]) {
            let wall = new THREE.Mesh(wallGeo, wallMat);
            wall.rotation.y = Math.PI / 2;
            wall.position.set(x * cellSize - cellSize / 2, wallHeight / 2, y * cellSize);
            scene.add(wall);
          }
        }
      }
      let goalGeo = new THREE.BoxGeometry(cellSize * 0.5, 0.2, cellSize * 0.5);
      let goalMat = new THREE.MeshLambertMaterial({ color: 0xff0000 });
      let goal = new THREE.Mesh(goalGeo, goalMat);
      goal.position.set((cols - 2) * cellSize, 0.1, (rows - 2) * cellSize);
      scene.add(goal);
    }

    function createPlayer() {
      let playerGeo = new THREE.SphereGeometry(cellSize * 0.25, 16, 16);
      let playerMat = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
      playerMesh = new THREE.Mesh(playerGeo, playerMat);
      playerMesh.position.set(player.x * cellSize, cellSize * 0.5, player.y * cellSize);
      scene.add(playerMesh);
    }

    function triggerEvent(x, y) {
      let regionType = regions[y][x].type;
      let rand = Math.random() * 100;
      let eventProbs = {
        'Normal': { treasure: 20, trap: 10, nothing: 70 },
        'Danger': { treasure: 10, trap: 40, nothing: 50 },
        'Treasure': { treasure: 50, trap: 10, nothing: 40 },
        'Safe': { treasure: 30, trap: 0, nothing: 70 }
      };
      let probs = eventProbs[regionType];
      if (rand < probs.treasure) {
        player.score += 10;
        player.hp = Math.min(player.hp + 10, 100);
        alert(`Found Treasure in ${regionType} region! +10 Score, +10 HP. Score: ${player.score}, HP: ${player.hp}`);
      } else if (rand < probs.treasure + probs.trap) {
        player.hp -= 40;
        alert(`Hit a Trap in ${regionType} region! -40 HP. Score: ${player.score}, HP: ${player.hp}`);
        if (player.hp <= 0) {
          alert(`Game Over! HP reached 0. Final Score: ${player.score}`);
          resetGame();
        }
      } else {
        alert(`Nothing happened in ${regionType} region. Score: ${player.score}, HP: ${player.hp}`);
      }
      updateHUD();
    }

    function movePlayer(keyCode) {
      if (animationState.isAnimating) return; // Prevent new actions during animation
      let newX = player.x;
      let newY = player.y;
      let wallIndex;

      if (keyCode === 38) {
        if (player.direction === 0) { // North
          newY--;
          wallIndex = 0;
        } else if (player.direction === 1) { // East
          newX++;
          wallIndex = 1;
        } else if (player.direction === 2) { // South
          newY++;
          wallIndex = 2;
        } else if (player.direction === 3) { // West
          newX--;
          wallIndex = 3;
        }
        if (newX >= 0 && newX < cols && newY >= 0 && newY < rows && !maze[player.y][player.x].walls[wallIndex]) {
          animationState = {
            isAnimating: true,
            type: 'move',
            startTime: performance.now(),
            duration: 300,
            startPos: { x: player.x * cellSize, z: player.y * cellSize },
            endPos: { x: newX * cellSize, z: newY * cellSize }
          };
          player.x = newX;
          player.y = newY;
          playerMesh.position.set(player.x * cellSize, cellSize * 0.5, player.y * cellSize);
          triggerEvent(newX, newY);
          if (player.x === cols - 2 && player.y === rows - 2) {
            alert(`Congratulations! You reached the end! Final Score: ${player.score}, HP: ${player.hp}`);
            resetGame();
          }
        }
      }
    }

    function rotatePlayer(direction) {
      if (animationState.isAnimating) return; // Prevent new actions during animation
      let newDirection = player.direction;
      let deltaYaw;
      if (direction === 'right') {
        newDirection = (player.direction + 1) % 4;
        deltaYaw = -Math.PI / 2; // Clockwise rotation
      } else if (direction === 'left') {
        newDirection = (player.direction - 1 + 4) % 4;
        deltaYaw = Math.PI / 2; // Counterclockwise rotation
      }
      animationState = {
        isAnimating: true,
        type: 'rotate',
        startTime: performance.now(),
        duration: 300,
        startYaw: getCurrentYaw(),
        deltaYaw: deltaYaw
      };
      player.direction = newDirection;
    }

    function getCurrentYaw() {
      if (player.direction === 0) return 0;
      else if (player.direction === 1) return -Math.PI / 2;
      else if (player.direction === 2) return Math.PI;
      else return Math.PI / 2;
    }

    function resetGame() {
      scene.clear();
      const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
      scene.add(ambientLight);
      radarLight = new THREE.SpotLight(0x00ff00, 0.5, radarRange * cellSize * 2, Math.PI / 4);
      scene.add(radarLight);
      maze = generateMaze(cols, rows);
      regions = generateRegions();
      player = { x: 1, y: 1, score: 0, hp: 100, direction: 0 };
      createMazeGeometry();
      createPlayer();
      updateHUD();
      updateCamera();
      animationState.isAnimating = false;
    }

    function updateCamera() {
      if (animationState.isAnimating) {
        let elapsed = performance.now() - animationState.startTime;
        let t = Math.min(elapsed / animationState.duration, 1);

        if (animationState.type === 'move') {
          let x = animationState.startPos.x + (animationState.endPos.x - animationState.startPos.x) * t;
          let z = animationState.startPos.z + (animationState.endPos.z - animationState.startPos.z) * t;
          camera.position.set(x, cellSize * 0.5, z);
        } else if (animationState.type === 'rotate') {
          let yaw = animationState.startYaw + animationState.deltaYaw * t;
          camera.rotation.set(0, yaw, 0);
        }

        if (t >= 1) {
          animationState.isAnimating = false;
          // Snap to final position/rotation
          camera.position.set(player.x * cellSize, cellSize * 0.5, player.y * cellSize);
          camera.rotation.set(0, getCurrentYaw(), 0);
        }
      } else {
        camera.position.set(player.x * cellSize, cellSize * 0.5, player.y * cellSize);
        camera.rotation.set(0, getCurrentYaw(), 0);
      }
      camera.rotation.order = 'YXZ';
    }

    function animate() {
      requestAnimationFrame(animate);
      radarLight.position.set(player.x * cellSize, 1, player.y * cellSize);
      radarLight.target.position.set(
        player.x * cellSize + Math.cos(radarAngle) * radarRange * cellSize,
        0,
        player.y * cellSize + Math.sin(radarAngle) * radarRange * cellSize
      );
      radarLight.target.updateMatrixWorld();
      radarAngle += 0.05;
      updateCamera();
      renderer.render(scene, camera);
    }

    function updateHUD() {
      document.getElementById('hud').innerText = `Score: ${player.score}  HP: ${player.hp}`;
    }

    function onWindowResize() {
      let size = Math.min(window.innerWidth, window.innerHeight - 80, 800);
      renderer.setSize(size, size);
      camera.aspect = size / size;
      camera.updateProjectionMatrix();
    }

    init();
  </script>
</body>
</html>